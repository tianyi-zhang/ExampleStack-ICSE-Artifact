<p>A few comments:</p>

<ul>
<li>Your <code>equals</code> method <strong>does not</strong> override the <code>equals</code> method of <code>Object</code> (argument should be of <code>Object</code> type, not <code>data</code> type).</li>
<li>You should improve your <code>equals</code> method to account for nulls etc.</li>
<li>And finally, you should override <code>hashcode()</code> too when you override <code>equals()</code> - if not you might encounter some weird behaviors when using Sets or Maps for example. </li>
</ul>

<p>If you properly override the <code>equals</code> method, you can then just use the <code>remove</code> method.
See below the auto generated <code>equals</code> and <code>hashcode</code> generated by Netbeans, amended to use the <code>equalsIgnoreCase</code> method.</p>

<pre><code>public static void main(String[] args) {
    List&lt;Data&gt; list = new ArrayList&lt;Data&gt;();
    list.add(new Data("a", "b"));
    list.add(new Data("a", "c"));
    System.out.println(list.size()); //2
    list.remove(new Data("A", "b"));
    System.out.println(list.size()); //1
}

public static class Data {

    public String a;
    public String b;

    public Data(String a, String b) {
        this.a = a;
        this.b = b;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        final Data other = (Data) obj;
        boolean sameA = (this.a == other.a) || (this.a != null &amp;&amp; this.a.equalsIgnoreCase(other.a));
        if (!sameA) return false;
        boolean sameB = (this.b == other.b) || (this.b != null &amp;&amp; this.b.equalsIgnoreCase(other.b));
        if (!sameB) return false;
        return true;
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 89 * hash + (this.a == null ? 0 :this.a.toUpperCase().hashCode());
        hash = 89 * hash + (this.b == null ? 0 : this.b.toUpperCase().hashCode());
        return hash;
    }

}
</code></pre>
