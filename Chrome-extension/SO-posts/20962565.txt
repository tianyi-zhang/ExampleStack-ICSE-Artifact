<p>I've edited the code a little bit and made it Java from <a href="http://devmag.org.za/2009/04/25/perlin-noise/" rel="nofollow">http://devmag.org.za/2009/04/25/perlin-noise/</a></p>

<pre><code>private static Random random = new Random(new Random().nextLong());

private static float[][] generateWhiteNoise(int width, int height) {
    float[][] noise = new float[width][height];

    for (int i = 0; i &lt; width; i++) {
        for (int j = 0; j &lt; height; j++) {
            noise[i][j] = (float) random.nextDouble() % 1;
        }
    }

    return noise;
}

private static float[][] generateSmoothNoise(float[][] baseNoise, int octave) {
    int width = baseNoise.length;
    int height = baseNoise[0].length;

    float[][] smoothNoise = new float[width][height];

    int samplePeriod = 1 &lt;&lt; octave; // calculates 2 ^ k
    float sampleFrequency = 1.0f / samplePeriod;

    for (int i = 0; i &lt; width; i++) {
        // calculate the horizontal sampling indices
        int sample_i0 = (i / samplePeriod) * samplePeriod;
        int sample_i1 = (sample_i0 + samplePeriod) % width; // wrap around
        float horizontal_blend = (i - sample_i0) * sampleFrequency;

        for (int j = 0; j &lt; height; j++) {
            // calculate the vertical sampling indices
            int sample_j0 = (j / samplePeriod) * samplePeriod;
            int sample_j1 = (sample_j0 + samplePeriod) % height; // wrap
                                                                    // around
            float vertical_blend = (j - sample_j0) * sampleFrequency;

            // blend the top two corners
            float top = interpolate(baseNoise[sample_i0][sample_j0],
                    baseNoise[sample_i1][sample_j0], horizontal_blend);

            // blend the bottom two corners
            float bottom = interpolate(baseNoise[sample_i0][sample_j1],
                    baseNoise[sample_i1][sample_j1], horizontal_blend);

            // final blend
            smoothNoise[i][j] = interpolate(top, bottom, vertical_blend);
        }
    }

    return smoothNoise;
}

private static float interpolate(float x0, float x1, float alpha) {
    return x0 * (1 - alpha) + alpha * x1;
}

private static float[][] generatePerlinNoise(float[][] baseNoise,
        int octaveCount) {
    int width = baseNoise.length;
    int height = baseNoise[0].length;

    float[][][] smoothNoise = new float[octaveCount][][]; // an array of 2D
                                                            // arrays
                                                            // containing

    float persistance = 0.5f;

    // generate smooth noise
    for (int i = 0; i &lt; octaveCount; i++) {
        smoothNoise[i] = generateSmoothNoise(baseNoise, i);
    }

    float[][] perlinNoise = new float[width][height];
    float amplitude = 0.0f; // the bigger, the more big mountains
    float totalAmplitude = 0.0f;

    // blend noise together
    for (int octave = octaveCount - 1; octave &gt;= 0; octave--) {
        amplitude *= persistance;
        totalAmplitude += amplitude;

        for (int i = 0; i &lt; width; i++) {
            for (int j = 0; j &lt; height; j++) {
                perlinNoise[i][j] += smoothNoise[octave][i][j] * amplitude;
            }
        }
    }

    for (int i = 0; i &lt; width; i++) {
        for (int j = 0; j &lt; height; j++) {
            perlinNoise[i][j] /= totalAmplitude;
            perlinNoise[i][j] = (float) (Math.floor(perlinNoise[i][j] * 25));
        }
    }

    return perlinNoise;
}
private void generate(){
float[][] noise = generatePerlinNoise(generateWhiteNoise(width, height), 5/*octave count*/);
//...
</code></pre>

<p>}</p>
