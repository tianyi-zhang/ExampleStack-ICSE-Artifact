<p>AWT offers image scaling with different modes. For downscaling, <strong>Area Averaging</strong> offers the best quality. One could of course re-implement the area averaging scaling algorithm for SWT, or, for a quick solution which often suffices:</p>

<ul>
<li><strong>convert</strong> the <strong>SWT</strong> image <strong>to</strong> an <strong>AWT</strong> image</li>
<li><strong>rescale</strong> it using an appropriate mode (area averaging if downscaling, bilinerar otherwise)</li>
<li><strong>convert it back</strong> to an SWT image</li>
</ul>

<p>The code to convert between SWT and AWT images can be found <a href="http://www.java2s.com/Code/Java/SWT-JFace-Eclipse/ConvertbetweenSWTImageandAWTBufferedImage.htm">here</a>.</p>

<pre><code>/**
 * Resizes an image, using the given scaling factor. Constructs a new image resource, please take care of resource
 * disposal if you no longer need the original one. This method is optimized for quality, not for speed.
 * 
 * @param image source image
 * @param scale scale factor (&lt;1 = downscaling, &gt;1 = upscaling)
 * @return scaled image
 */
public static org.eclipse.swt.graphics.Image resize (org.eclipse.swt.graphics.Image image, float scale) {
    int w = image.getBounds().width;
    int h = image.getBounds().height;

    // convert to buffered image
    BufferedImage img = convertToAWT(image.getImageData());

    // resize buffered image
    int newWidth = Math.round(scale * w);
    int newHeight = Math.round(scale * h);

    // determine scaling mode for best result: if downsizing, use area averaging, if upsizing, use smooth scaling
    // (usually bilinear).
    int mode = scale &lt; 1 ? BufferedImage.SCALE_AREA_AVERAGING : BufferedImage.SCALE_SMOOTH;
    java.awt.Image scaledImage = img.getScaledInstance(newWidth, newHeight, mode);

    // convert the scaled image back to a buffered image
    img = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_RGB);
    img.getGraphics().drawImage(scaledImage, 0, 0, null);

    // reconstruct swt image
    ImageData imageData = convertToSWT(img);
    return new org.eclipse.swt.graphics.Image(Display.getDefault(), imageData);
}

public static BufferedImage convertToAWT (ImageData data) {
    ColorModel colorModel = null;
    PaletteData palette = data.palette;
    if (palette.isDirect) {
        colorModel = new DirectColorModel(data.depth, palette.redMask, palette.greenMask, palette.blueMask);
        BufferedImage bufferedImage = new BufferedImage(colorModel, colorModel.createCompatibleWritableRaster(data.width, data.height),
            false, null);
        WritableRaster raster = bufferedImage.getRaster();
        int[] pixelArray = new int[3];
        for (int y = 0; y &lt; data.height; y++) {
            for (int x = 0; x &lt; data.width; x++) {
                int pixel = data.getPixel(x, y);
                RGB rgb = palette.getRGB(pixel);
                pixelArray[0] = rgb.red;
                pixelArray[1] = rgb.green;
                pixelArray[2] = rgb.blue;
                raster.setPixels(x, y, 1, 1, pixelArray);
            }
        }
        return bufferedImage;
    } else {
        RGB[] rgbs = palette.getRGBs();
        byte[] red = new byte[rgbs.length];
        byte[] green = new byte[rgbs.length];
        byte[] blue = new byte[rgbs.length];
        for (int i = 0; i &lt; rgbs.length; i++) {
            RGB rgb = rgbs[i];
            red[i] = (byte) rgb.red;
            green[i] = (byte) rgb.green;
            blue[i] = (byte) rgb.blue;
        }
        if (data.transparentPixel != -1) {
            colorModel = new IndexColorModel(data.depth, rgbs.length, red, green, blue, data.transparentPixel);
        } else {
            colorModel = new IndexColorModel(data.depth, rgbs.length, red, green, blue);
        }
        BufferedImage bufferedImage = new BufferedImage(colorModel, colorModel.createCompatibleWritableRaster(data.width, data.height),
            false, null);
        WritableRaster raster = bufferedImage.getRaster();
        int[] pixelArray = new int[1];
        for (int y = 0; y &lt; data.height; y++) {
            for (int x = 0; x &lt; data.width; x++) {
                int pixel = data.getPixel(x, y);
                pixelArray[0] = pixel;
                raster.setPixel(x, y, pixelArray);
            }
        }
        return bufferedImage;
    }
}

public static ImageData convertToSWT (BufferedImage bufferedImage) {
    if (bufferedImage.getColorModel() instanceof DirectColorModel) {
        DirectColorModel colorModel = (DirectColorModel) bufferedImage.getColorModel();
        PaletteData palette = new PaletteData(colorModel.getRedMask(), colorModel.getGreenMask(), colorModel.getBlueMask());
        ImageData data = new ImageData(bufferedImage.getWidth(), bufferedImage.getHeight(), colorModel.getPixelSize(), palette);
        WritableRaster raster = bufferedImage.getRaster();
        int[] pixelArray = new int[3];
        for (int y = 0; y &lt; data.height; y++) {
            for (int x = 0; x &lt; data.width; x++) {
                raster.getPixel(x, y, pixelArray);
                int pixel = palette.getPixel(new RGB(pixelArray[0], pixelArray[1], pixelArray[2]));
                data.setPixel(x, y, pixel);
            }
        }
        return data;
    } else if (bufferedImage.getColorModel() instanceof IndexColorModel) {
        IndexColorModel colorModel = (IndexColorModel) bufferedImage.getColorModel();
        int size = colorModel.getMapSize();
        byte[] reds = new byte[size];
        byte[] greens = new byte[size];
        byte[] blues = new byte[size];
        colorModel.getReds(reds);
        colorModel.getGreens(greens);
        colorModel.getBlues(blues);
        RGB[] rgbs = new RGB[size];
        for (int i = 0; i &lt; rgbs.length; i++) {
            rgbs[i] = new RGB(reds[i] &amp; 0xFF, greens[i] &amp; 0xFF, blues[i] &amp; 0xFF);
        }
        PaletteData palette = new PaletteData(rgbs);
        ImageData data = new ImageData(bufferedImage.getWidth(), bufferedImage.getHeight(), colorModel.getPixelSize(), palette);
        data.transparentPixel = colorModel.getTransparentPixel();
        WritableRaster raster = bufferedImage.getRaster();
        int[] pixelArray = new int[1];
        for (int y = 0; y &lt; data.height; y++) {
            for (int x = 0; x &lt; data.width; x++) {
                raster.getPixel(x, y, pixelArray);
                data.setPixel(x, y, pixelArray[0]);
            }
        }
        return data;
    }
    return null;
}
</code></pre>
